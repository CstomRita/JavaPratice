# 第八章 数组和矩阵问题

## 在行列中排好序的数组中找数

【题目描述】

给定一个N×M的整形矩阵matrix和一个整数K, matrix的每一行和每一列都是排好序的。
实现一个函数，判断K是否在matrix中

【要求】

时间复杂度为O(N+M)O(N+M)，额外空间复杂度为O(1)O(1)。

【实现类】

class FindInSortMatrix

【思路】

对于排序好的二维数组，一般从**右上角遍历到左下角**，或者左下角遍历遍历到右上角

如果小于target，那么这一行都小于target,向下面一行 i+1

如果大于target，则向左遍历j--，如果找到小于target的，向下i+1，如果都比target大则false，如果找到target true

在寻找过程中是按照左上角到target的路线寻找的，时间复杂度O(i+j)

1. 小于target i++; 
2. 大于target j--;

## 可整合数组的最大长度

【题目描述】

先给出可整合数组的定义：

如果一个数组在排序之后，每相邻两个数的差的绝对值都为1，或者该数组长度为1，则该数组为可整合数组。例如，[5, 3, 4, 6, 2]排序后为[2, 3, 4, 5, 6]，符合每相邻两个数差的绝对值都为1，所以这个数组为可整合数组

给定一个数组arr, 请返回其中最大可整合子数组的长度。

例如，[5, 5, 3, 2, 6, 4, 3]的最大可整合子数组为[5, 3, 2, 6, 4]，所以请返回5

【要求】
时间复杂度为O(n<sup>2</sup>)，空间复杂度为O(n)

【实现类】

class MaxLengthOfArray

【思路】

