
# 滑动窗口算法 

滑动窗口算法在数组和字符串中应用很多

可以用来解决子序列的问题

它的定义是[L,R）这样左闭右开的区间窗口代表求解的子序列

一开始L=0 R=0 

R 不断右移增加，当R不再满足右移延伸的条件时

移动L右移，至再次满足R右移条件（通过remove之类的），移动至重复元素+1的位置才能令R满足条件

然后再重复移动R

一般情况下时间复杂度为O(2N)

## 再优化

一般子序列重复元素出现的问题

我们知道如何快速判断是否有重复元素 使用哈希表Map 、 Set这些都可以

上面的一般解法可以通过Set实现

这里有这么一个点：我们移动L的目的是什么？ 是为了满足R可以继续移动的条件

当前阻止R继续移动的是集合中存在了重复元素，也就是说L必须移动到与当前R所在位置重复元素的位置，并将其remove，R才可以继续移动

那么我们就可以依据Map<值，下标>直接得到L需要移动的位置

#### 那么我们再来看一个问题 remove是必须的吗

我们之前的算法：

如果满足： R 右移 set.add(R)

如果不满足： L右移 set.remove(L)

这样set中是遍历到最后的子序列

如果我们仅仅需要子序列的长度，那么 R-L就可以代表，真的需要remove吗？？

如果不remove：

R 满足条件右移，不满足条件依然右移map.put

L 不满足条件时，通过Map<值，下标>直接得到L需要移动的位置，而且没有删除remove，一旦map中出现了重复值，再下一次出现重复值时需要向右移方向移动L，也就是比当前

L = Max(L,map.get(值)）此时L处于重复元素的位置

然后我们利用map.put(值)实际上是可以对key值所在的value做一个更新的

