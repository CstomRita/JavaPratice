# 给定一个数组nums,N个数相加等于target

##2元祖 twoSum

主要有两种方法，一种是哈希表，一种是双指针法

### 哈希表(Map、Set)

将数组中元素放入哈希表中，向后遍历执行向前查找动作，利用map.contains(key)查找有没有target-nums[i]这个元素

获取其下标

因此map.put()是不会存放重复值的，因此结果中不会出现重复元素

在这个过程中，

一个是将所有元素put到map中，一个是数组遍历时查找后面有没有map.contains()

这样的话就是两个for循环


#### 向后遍历的进行向前查找的动作，记住这个思想

这个思想可以为我们将两个循环合并在一个

数组向后遍历的过程中put每一个元素，查找时向前查找，此时查找的都是已经put进去的元素，利用一个for循环便可实现


用Map\Set看具体的题目要求，如果要求返回下标等等除了具体的数值还需要存放别的信息的使用Map

利用哈希表依然有可能返回重复元素：

[1,3,5,8,2,3,7,0] target:8 的时候 

第一个5 会get前面的 3

第二个3 会get前面的 5

这样就会产生重复元素[3,5] [5,3] 

去除重复元素：nums[i]如果在哈希表中存在则直接跳过，但是需要排除target = 2 * nums[i]的情况

故ums[i]如果在哈希表中且target != 2 * nums[i]时跳过

### 双指针法

双指针法需要利用数组有序的条件，一个指向数组头，一个指向数组尾

首先要对数组排序 Arrays.sort()

如果相加比target大，数组尾部的前移

如果相加比target小，数组头部的后移

如果相加等于target，则说明满足条件，数组尾部前移。数组头部的后移，开启下一个查找

这种查找下，会查找出所有相加等于target的元素组合

例如[1,1,2,0,1,1]target为2时，会返回[1,1],[1,1],[2,0]

也就是返回结果组合里会包含重复元素

需要再做特别处理： 

相加等于target时数组尾部前移到和此处值不一样的位置，一个while循环（注意i<j）

数组头部的后移到和此处值不一样的位置，一个while循环注意i<j）


## 3元组

3元组的思想：在二元组的外面嵌套一层for循环

遍历数组：选择nums[i]作为固定的第一个元素，在后面的数组中查找相加等于 target-nums[i]的两个元素

这就是二元组哇哇

遍历数组时如果nums[i]重复出现过则直接跳过


如果使用哈希表要及時clear和put

